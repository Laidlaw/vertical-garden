<!DOCTYPE html>
<html lang="en-us">
    <head>

        <meta charset="utf-8">
        <title>DoCSSa – Sass based CSS architecture and methodology</title>

        <link rel="shortcut icon" href="favicon.ico">

        <meta name="description"
              content="DoCSSa {dok~sa} — Deferred Object CSS Architecture — Sass based CSS architecture and methodology for large & long lived sites.">

        <meta http-equiv="X-UA-Compatible" content="IE=Edge">


        <link rel="stylesheet" href="css/custom.css">
        <script src="js/modernizr.custom.20463.js"></script>

    </head>

    <!--[if IE 7]>
    <body class="lt-ie9 lt-ie8"> <![endif]-->
    <!--[if IE 8]>
    <body class="lt-ie9"> <![endif]-->
    <!--[if gt IE 8]><!-->
    <body> <!--<![endif]-->


        <div class="mainContainer">

            <header class="mainHeader">
                <h1 class="mainTitle">
                    DoCSSa {dok~sa}
                </h1>

                <h2 class="mainSubtitle">Sass based CSS architecture and methodology</h2>
            </header>

            <nav class="mainNav">
                <ul class="mainMenu">
                    <li class="mainMenu_item">
                      <a class="mainMenu_link" href="#">Home</a>
                    </li>
                    <li class="mainMenu_item">
                        <a class="mainMenu_link" href="#about">About</a>
                    </li>
                    <li class="mainMenu_item">
                        <a class="mainMenu_link" href="#fileStructure">File Structure</a>
                    </li>
                    <li class="mainMenu_item">
                        <a class="mainMenu_link" href="#components">Components</a>
                    </li>
                    <li class="mainMenu_item">
                        <a class="mainMenu_link" href="#namingConventions">Naming conventions</a>
                    </li>
                    <li class="mainMenu_item">
                      <a class="mainMenu_link" href="#responsive">Responsive</a>
                    </li>
                    <li class="mainMenu_item">
                        <a class="mainMenu_link" href="#gettingStarted">Getting started</a>
                    </li>
                    <li class="mainMenu_item mainMenu_item--highlighted">
                        <a class="mainMenu_link" href="#contributing">Contributing</a>
                    </li>
                </ul>
            </nav>
            <button class="navOpener"></button>

            <article class="mainContent">

                <hr class="articleSeparator">

                <section class="mainSection" id="about">

                    <header class="mainSection_header">
                        <h1 class="mainSection_title">About</h1>
                    </header>

                    <div class="mainSection_body">

                        <h2 class="mainSection_subtitle">What is DoCSSa ?</h2>

                        <p>DoCSSa is a CSS architecture and methodology that tries to combine all the good parts of the current state of
                            the art.<br>
                            It is intended for use in large, long lived sites, on which many frontend developers may be working
                            over time.<br>
                            The name stands for <em>Deferred Object CSS Architecture</em>.</p>

                        <h2 class="mainSection_subtitle">What are the benefits of doing things the DoCSSa way?</h2>

                        <ul class="firstOrderList">
                            <li class="firstOrderList_item">
                                        <span class="firstOrderList_item_content">
                                            DoCSSa lets you define snippets of style you can reuse everywhere, without repeating yourself,
                                            while keeping the flexibility you need and correct semantics.
                                        </span>
                            </li>
                            <li class="firstOrderList_item">
                                        <span class="firstOrderList_item_content">
                                            DoCSSa is scalable and maintainable. It is based on Sass, and suggests a file structure that
                                            allows for small, modular components. As most thing have a dedicated place, the developers can
                                            easily find the part they have to work on, update it, remove obsolete rules, etc.
                                        </span>
                            </li>
                            <li class="firstOrderList_item">
                                        <span class="firstOrderList_item_content">
                                            DoCSSa keeps your CSS from leaking to unwanted places by using a naming convention for classnames,
                                            which reflects the modularity of the reusable blocks at work and their constitutive elements.
                                        </span>
                            </li>
                            <li class="firstOrderList_item">
                                        <span class="firstOrderList_item_content">
                                            DoCSSa is easy to setup and as flexible as you want it to be. It's only a starting point. Where
                                            you go from it is up to you and your team!
                                        </span>
                            </li>
                        </ul>

                        <h2 class="mainSection_subtitle">Why does DoCSSa exist ?</h2>

                        <p>As frontend web developers, we are living in a world of evergrowing complexity. What once was a
                            relatively easy thing to do (putting aside browsers inconsistencies) has grown into a very complex,
                            dynamic, everchanging reality.</p>

                        <p>We can't put up to the pace, and honestly do we really want to? Wouldn't we be better off by planning
                            ahead what can be planned and setting up a flexible structure in order to be more efficient and less
                            under pressure when the rough times come ? The way we see it, the more work we
                            can avoid by having defined the right tools and the right architecture ahead of time, the better.</p>

                        <p>DoCSSa is our attempt at an organization that aims toward a faster workflow without sacrificing the
                            long run flexibility.</p>

                        <h2 class="mainSection_subtitle">How does DoCSSa bring its benefits ?</h2>

                        <p>DoCSSa is based on Sass, and leverages some of its key features to achieve its goal.
                            Most notably, DoCSSa takes advantage of placeholders, mixins, and imports.
                            It also suggests a file system organisation and a BEM based naming convention, and integrates
                            the core ideas found in OOCSS, SmaCSS and DRY CSS.</p>

                    </div>

                </section>

                <hr class="articleSeparator">

                <section class="mainSection" id="fileStructure">

                    <header class="mainSection_header">
                        <h1 class="mainSection_title">File Structure</h1>
                    </header>

                    <div class="mainSection_body">

                        <h2 class="mainSection_subtitle">Basics</h2>

                        <p>In DoCSSa, the file system is divided in four main directories in the sass folder :</p>

                        <ul class="firstOrderList">
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="navLink" href="#fileStructure_base">base</a>
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="navLink" href="#fileStructure_components">components</a>
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="navLink" href="#fileStructure_specifics">specifics</a>
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="navLink" href="#fileStructure_vendor">vendor</a>
                                </div>
                            </li>
                        </ul>

                        <p>Each base folder has a specific role, and CSS rules for a particular set of elements will end up in one of
                            these directories, according to their nature.<br>
                            The structure has a single point of entry, which we'll call <em>custom.scss</em>.
                            This file is located at the root of the sass folder.</p>

                        <p class="note">In most cases, it will be the only file with no
                            underscore(_) prefix : as you may know, the .scss to .css convertion process in Sass only converts
                            files that don't have an underscore in front of them. Most of the files in our structure being imported
                            by other files, they don't need to be rendered directly.<br>
                            Only components may be rendered separately, in order to be able to dynamically load them if needed,
                            but we'll get back to it.
                        </p>

                        <p>The main .scss file will look something like this :</p>

                        <div class="sample">
                            <ul class="sampleHeader">
                                <li class="sampleHeader_item _is_current">
                                    <span class="sampleHeader_link">// custom.scss</span>
                                </li>
                            </ul>

<pre class="codeSample">
@charset "UTF-8";

/*!
========== INIT
*/
@import 'vendor/_normalize';


/*!
========== BASE
*/
// variables, fonts, mixins, helpers... common styles used across the entire site
@import 'base/__base';


/*!
========== COMPONENTS
*/
// reusable components
@import 'components/__components';


/*!
========== SPECIFICS
*/
// declarations specific to the project, organized according to the items/sections represented
@import 'specifics/__specifics';
</pre>
                        </div>

                            <p>As you can see, it mostly acts as an aggregator for other files, which themselves import some
                                other scss files, and so on. With a well thought organization, this construct can prove very powerful.</p>

                            <p class="note">On a sidenote, remember that Sass is only a CSS precompiler, so you'll end up with only one .css file
                                with all the goodies, not a bunch of HTTP requests!</p>

                            <p>Here is an overview of what a basic file system might look like :</p>

                            <samp class="sampleTitle">// file system</samp>
<pre class="codeSample">
sass
¦   custom.scss
¦
+---base
¦   ¦   __base.scss
¦   ¦   _config.scss
¦   ¦
¦   +---project
¦   ¦       __project.scss
¦   ¦       _fonts.scss
¦   ¦       _globals.scss
¦   ¦       _helpers.scss
¦   ¦       _variables.scss
¦   ¦
¦   +---utils
¦           __utils.scss
¦           _helpers.scss
¦           _mixins.scss
¦           _system.scss
¦
+---components
¦   ¦   __components.scss
¦   ¦
¦   +---button
¦   ¦       _button.scss
¦   ¦
¦   +---roundedButton
¦   ¦       _roundedButton.scss
¦   ¦
¦   +---tabs
¦   ¦       _tabs.scss
¦   ¦       tabs.standalone.scss
¦   ¦       tabs.standalone.html
¦   ¦
¦   +---verticalMenu
¦           _verticalMenu.scss
¦
+---specifics
¦   ¦   __specifics.scss
¦   ¦   _main.scss
|   |   _inbox.scss
¦   ¦
¦   +---popins
¦           __popins.scss
¦           _popin-congratulations.scss
¦           _popin-loginForm.scss
¦
+---vendor
    _normalize.scss
</pre>


                        <h2 class="mainSection_subtitle" id="fileStructure_base">Base folder</h2>

                        <p>The "base" folder contains rules that are global to the site. It is divided in two parts : </p>
                        <ul class="firstOrderList">
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="navLink" href="#fileStructure_base_utils">utils</a>
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="navLink" href="#fileStructure_base_project">project</a>
                                </div>
                            </li>
                        </ul>
                        <p class="note">Both summary files (__project.scss and __utils.scss) for those folders import the <em>base/_config.scss</em> file which contains
                            configuration information required by both the system and the project. If you're wondering why we don't
                            import the config from the __base.scss file, you're asking yourself the right questions! We had to
                            stray a bit from our convention about sass files organization on that one in order to ease the standalone components generation.
                            We assumed it was better to import the file twice in "base" than once in "base" and then once for each
                            component declaration.<br>
                            As of today, this file contains $baseFontSize which is required for the
                            "remIt" mixin, and $breakpoints which is required for cross-media placeholders.</p>
                        <p>
                            <strong id="fileStructure_base_utils">Utils</strong> contains only things that don't need to change
                            from a project to another. As of today,
                            it consists of <em>_system</em>, <em>_helpers</em>, and <em>_mixins</em>.
                        </p>
                        <ul class="secondaryList">
                            <li class="secondaryList_item">
                                <div class="secondaryList_item_content">
                                    <p><em>_system</em> is a special file the contains tools used by DoCSSa.<br>
                                        Most notably, it contains a <em>define</em> mixin used to allow inclusion of placeholders
                                        from several places without generating duplicate content, and <em>_add()/_use()</em> mixins for
                                      handling cross media placeholders.
                                    </p>

                                    <p class="note">To have a
                                        specific
                                        component's CSS file rendered, the component's .scss file needs to import the placeholders
                                        contained in <em>_helpers.scss</em>.
                                        But when
                                        generating the whole project's CSS, we don't want that multiple import to screw up the
                                        output.
                                        <em>define</em> is a simple mixin taking advantage of the <em>@content</em> instruction Sass
                                        provides, which
                                        allows us in the end to have a clean .css file even though we import our placeholders file several
                                        times
                                        from various places. Dig in the provided example structure if you want to find out how
                                        this works.
                                    </p>

                                    <p class="note">As you'll notice, DoCSSa makes heavy use of placeholders. By default, Sass
                                        doesn't like it when you try to use a placeholder defined on the root from within a
                                        media query and will throw nasty errors at you for that. Thankfully, some nice folks have
                                        found a way around it, and we've implemented it in DoCSSa. More on that in the "Responsive"
                                        section.
                                    </p>
                                </div>
                            </li>
                            <li class="secondaryList_item">
                                <div class="secondaryList_item_content">
                                    <p><strong>_helpers</strong> are Sass placeholders that represent a simple
                                        CSS functionnality that can be implemented by many classes. For example, %clearfix can be extended
                                        by any class that would need to contain floats.
                                    </p>

                                    <p class="note">Placeholders have been a great addition to Sass. They are the magic that allows us to have
                                        an
                                        object
                                        oriented
                                        architecture without polluting the markup. For those not familiar with placeholders,
                                        they work a
                                        bit like mixins, but instead of placing a set of CSS rules within the selector
                                        implementing
                                        them, they add that selector to the list of selectors on which to apply a set of CSS rules.<br>
                                        This may not seem as much, but you'll see some of the awesome stuff we can do with
                                        it in the
                                        components section.</p>
                                </div>
                            </li>
                            <li class="secondaryList_item">
                                <div class="secondaryList_item_content">
                                    <p><strong>_mixins</strong> have quite the same purpose as placeholders,
                                        but they do require parameters.
                                        Mixins are
                                        particularily useful for handling vendor prefixes and fallbacks. For example, DoCSSa comes with
                                        a
                                        linear-gradient mixin that compiles to all required vendor prefixes (and only those required!)
                                        and generates a
                                        fallback color from the input values for browsers that don't support linear-gradient at all.
                                        DoCSSa
                                        recommends using Modernizr for feature detection and progressive enhancement, and the provided
                                        mixins
                                        implementing CSS3 features rely on it by default for their output, even though it can be
                                        disabled at include time.<br>
                                    </p>

                                    <p class="note">Mixins, like placeholders, can accumulate and enrich your library
                                        with no cost, as they are only compiled when used.<br>
                                        Mixins are a great way to avoid repetition when coding, but they end up in code
                                        repetition
                                        in the css output. That's why we only use them when they have to output something that
                                        needs to be configured.
                                        For generic code that can be reused as-is, we use placeholder helpers instead.</p>

                                    <aside class="exampleNote">
                                        <p>Here's what a mixin may look like in the <em>utils/_mixins</em> file :</p>

                                        <samp class="sampleTitle">// base/utils/_mixins.scss</samp>
<pre class="codeSample">
@mixin linear-gradient($from, $to, $fallback: '', $useModernizr: true) {

  $prefixes: getPrefixes(cssgradients, $useModernizr);

  #{map-get($prefixes, no)} &amp; {
    @if $fallback != '' {
      background-color: $fallback;
    } @else {
      background-color: mix($from, $to);
    }
  }

  #{map-get($prefixes, yes)} &amp; {
    background-image: -webkit-gradient(linear, left top, left bottom, from($from), to($to)); // Saf4+, Chrome
    background-image: -webkit-linear-gradient(top, $from, $to); // Chrome 10+, Saf5.1+, iOS 5+
    background-image: -moz-linear-gradient(top, $from, $to); // FF3.6+
    background-image: -o-linear-gradient(top, $from, $to); // Opera 11.10+
    background-image: linear-gradient(to bottom, $from, $to);
  }

}
</pre>

                                            <p>And an example of placeholder in the <em>utils/_helpers</em> file :</p>

                                            <samp class="sampleTitle">// base/utils/_helpers.scss</samp>

<pre class="codeSample">
@include _add(clearfix) {
  &amp;:before,
  &amp;:after {
    content: " ";
    display: table;
  }
  &amp;:after {
    clear: both;
  }
  *zoom: 1;
}
</pre>

                                        <p class="note">
                                            Note that we use <em>@include _add(clearfix)</em> here instead of <em>%clearfix</em>. This
                                            is a way to allow cross-media placeholders. More on that in the "responsive" section.
                                        </p>
                                    </aside>
                                </div>
                            </li>
                        </ul>


                        <p>
                            <strong id="fileStructure_base_project">Project</strong> has quite the same role as the <em>utils</em>
                            folder, but it is project
                            oriented while <em>utils</em> is intended to be kept and grow from a project to the next. As of today, it
                            consists of <em>_variables</em>, <em>_fonts</em>, <em>_globals</em>, and <em>_helpers</em>.
                        </p>

                        <ul class="secondaryList">
                            <li class="secondaryList_item">
                                <div class="secondaryList_item_content">
                                    <p><strong>_variables</strong> is were all site wide variables reside. Default values, color theme,
                                        configuration variables go into this file.
                                    </p>

                                    <p>Here's what the <em>_variables.scss</em> file might look like :</p>

                                    <samp class="sampleTitle">// _variables.scss</samp>

<pre class="codeSample">
/* _____ VARIABLES _____ */

// Generic
// ==========================================================================

$default-borderRadius: 4;
$containerWidth: 760;
$left-nav-width: 200;

$nav-variant: 'base';


// Colors
// ==========================================================================

$color-default-light:       #fff;
$color-default-dark:        #333;
$color-default-darker:      #000;

$color-main:                #449888;
$color-main-light:          #5cbcaa;
$color-main-lighter:        #a8d5cd;

$color-secondary:           #ee746f;

$color-alt:                 #f1ede4;
$color-alt-dark:            #c2c0bc;
$color-alt-light:           #f8f5ec;

$color-alt2:                #637c84;
</pre>

                                </div>
                            </li>

                            <li class="secondaryList_item">
                                <div class="secondaryList_item_content">
                                    <p>The <strong>_fonts</strong> file is used —you guessed it— for the font-families declaration.<br>
                                        In our implementation, we use a font mixin that is in charge of generating a bulletproof syntax
                                        according to the passed configuration for each needed font, according to a file naming convention.</p>

                                    <p class="note"> But where do we have to place the font files themselves, you may be wondering? Well, as
                                        this Sass structure is
                                        intended to be compiled to CSS in a different directory, the fonts will be in that directory.
                                        Typically, you'll have the <em>custom.scss</em> file in a "sass" folder" compiled to a
                                        <em>custom.css</em> in a
                                        "css" or "styles" folder. The font files will have to be there (preferably in a "fonts"
                                        subfolder in order to stay nice and tidy).<br>
                                        Same goes for all the image files you may be referring to in your stylesheets.
                                    </p>
                                </div>
                            </li>

                            <li class="secondaryList_item">
                                <div class="secondaryList_item_content">
                                    <p><strong>_globals</strong> contains rules that are global
                                        to the site. Things like box-sizing type, html font size, body background color,
                                        headings and link defaults, etc. are defined here. It is also be a good place to store
                                        your layout definition if it is used for all pages on the site.
                                    </p>
                                </div>
                            </li>

                            <li class="secondaryList_item">
                                <div class="secondaryList_item_content">
                                    <p><strong>_helpers</strong> contains placeholders helper that are specific to your current
                                        project. If you have a reusable visual component that wouldn't make sense in another project
                                        and can be applied to your selector through a simple @extend, this is where it belongs.
                                        For more advanced reusable components, the "components" section is what you're looking for.
                                    </p>
                                </div>
                            </li>
                        </ul>

                        <h2 class="mainSection_subtitle" id="fileStructure_components">Components folder</h2>

                        <p>
                            The "components" folder is where your complex ui-components are located. It plays quite the same
                            role as the <em>_helpers</em> file in the base/project folder, but in a way more evolved way. You can
                            think of it as configurable helpers on steroids.<br>
                            Components are so important in DoCSSa that we needed a dedicated section to explain all there is to know about them,
                            so we won't say much more about them here.
                        </p>

                        <h2 class="mainSection_subtitle" id="fileStructure_specifics">Specifics folder</h2>

                        <p>The "specifics" folder is your common playground. It is where you'll place the rules that don't belong
                            in the "base" or "components" folders. Until you become fluent with DoCSSa's organization rules, what will
                            eventually
                            end up in a component will probably exist in here first.</p>

                        <p>Specifics is the closest thing to your usual CSS file, except for it's organization. Everything in there
                            is split and dispatched in files and folders according to what they apply to.</p>

                        <p>By convention, we're using two underscores(__) as a prefix for files that act (mostly) as an import
                            summary,
                            and only one underscore(_) for files which are content only. This usually evolves with the
                            project: you
                            begin with an underscore prefixed file, you add another one, and at some point you stop calling them
                            directly from the main .scss file and you reorganize them in a folder with a summary file. </p>
                        <aside class="exampleNote">
                            <p>For example you might begin writing some rules in specifics/__specifics.scss, and as it grows
                                realize that
                                you have a bunch of rules all related to the popin windows. You'd then move those rules in a
                                _popin.scss
                                file and import that file from __specifics.scss.</p>

                            <p>
                                After a while, you'll notice that you added
                                some rules for a
                                bunch of specific popins on your site. That would be a good time to create a "popins" folder and
                                split
                                the specific popin rules to different files in that folder (say, popins/_popin-loginForm.scss
                                and
                                popins/_popin-congratulations.scss).<br>
                                Instead of importing _popins.scss from __specifics.scss, you'd then import popins/__popins.scss
                                instead,
                                and let this summary file import all the specific popins required for your project.</p>

                            <p>This allow you to have all your feature related files in the same folder, and one summary
                                specific to that kind
                                of feature which can import or leave out the files in its section as easily as commenting out a
                                line. If
                                at some point you realize that you don't want to use the congratulations popin anymore, all you
                                have to do
                                is to comment out the line importing its definition file (_popin-congratulations.scss) from the
                                popins summary
                                (popins/__popins.scss).</p>
                        </aside>

                        <p class="note">DoCSSa encourages you to keep your definitions tidy and reorganize in subfolders as soon as it makes
                            sense.<br>
                            No file should ever be big enough that you can't scroll through it in a few mousewheel movements
                            max.</p>

                        <p>Before everyone in your team is familiar with DoCSSa, it can be helpful for occasional contributors
                            wondering where to place their code to have a dedicated file. In such case, we recommend using
                            a <em>_inbox.scss</em> file in the "specifics" folder and ask them to commit their work in there.<br>
                            It shall be emptied regularly by a more experienced DoCSSa user, who would move the CSS rules
                            defined in there to the correct place in the architecture.
                        </p>


                        <h2 class="mainSection_subtitle" id="fileStructure_vendor">Vendor folder</h2>

                        <p>The <em>vendor</em> folder is where we place CSS files that come from third parties and can be updated at
                            any time. As the .scss syntax is CSS compatible, all we have to do is to rename the .css file to
                            .scss, in order for it to be integrated to the .css compilation instead of referenced by the CSS
                            file as a classic @import.</p>

                        <p class="note"><em>_normalize.scss</em> is an excellent candidate for this section, along with more project specific
                            third
                            party CSS.</p>
                    </div>

                </section>

                <hr class="articleSeparator">

                <section class="mainSection" id="components">

                    <header class="mainSection_header">
                        <h1 class="mainSection_title">Components</h1>
                    </header>

                    <div class="mainSection_body">
                        <h2 class="mainSection_subtitle">Introduction</h2>
                        <p>Components are an important part of DoCSSa. They are intended to be as reusable and
                            extendable as possible. Ideally, they should be reusable in a totally different project without
                            writing any additionnal code. They are, along with the placeholder helpers, the "Deferred Object" part of DoCCSa,
                            thanks to the power of
                            placeholders and mixins.
                        </p>
                        <p>We say the Object is Deferred because its core resides in an abstraction (the placeholders)
                            instead of being tied to a classname. DoCSSa's components are class agnostic. They are made of placeholders
                            and mixins. The placeholders
                            define a component, and a component mixin is in charge of binding those placeholders to one
                            or several HTML class(es). Thanks to the BEM naming convention, the class passed to the component mixin can be
                            a prefix for other classes onto which to bind placeholder functionalities.
                        </p>
                        <p>This allows for components to be instantiated on any class, and to be extendable if needed.
                        </p>
                        <p>As the component is not tied to a particular class, you can use it on whatever class you want, whenever you want,
                            from the CSS side. That means that you can (and should) keep a semantic meaning to your HTML classes, and change
                            their look and feel without having to modify the markup. When your markup comes from a RTE, this is a huge gain.
                            You can change the styling without asking the contributors to change their habits, and you can
                            affect everything already written without having to make search&amp;replace throughout a database or without
                            having a "red" class helper mean the color is going to be purple!
                        </p>
                        <p class="exampleNote">
                            For example, instead of having a link with the "button red"
                            classes, you can give it a "navTrigger" class and bind a button component with a red skin to it. You could
                            also use the same component on a "submitTrigger" class so that both look the same. When time comes
                            to have a different look for your submits, all you have to do is bind the submitTrigger to another component
                            and you're done, without affecting the navTriggers and without touching the markup.
                        </p>
                        <p>If you need a component
                            with a slightly different behaviour than the original one, you have two options : you can pass a parameter to
                            the mixin to change the binding (or rules), or you can create a subComponent that will import the component's
                            definition to get access to its placeholders, and make a new mixin that will handle the altered implementation.
                        </p>
                        <div class="exampleNote">
                            <p>For example, your component can bind the %exampleAltState placeholder to #{$selector}:hover by default,
                                but bind it to the #{$selector}_#{$hover} class for special cases.<br>
                                Here is what it could look like :
                            </p>

                            <samp class="sampleTitle">// component example</samp>
<pre class="codeSample">
// map the placeholders content to some selectors through a mixin
@mixin example($selector: '.example', $hover: ':hover', $param2: '', $defaultSkin: true) {

  #{$selector} {
    @extend %example;
  }

  #{$selector}_inner {
    @extend %exampleInner;
  }

  @if $hover == ':hover' {
    #{$selector}:hover {
      @extend %exampleAltState;
    }
  } @else {
    #{$selector}_#{$hover} {
      @extend %exampleAltState;
    }
  }

  @if $defaultSkin != false {
    @include example-skin-default($selector, $hover, $param2);
  }

}
</pre>

                        </div>
                        <p>In order to fulfill their role, components need to respect those two guidelines :</p>
                        <ul>
                            <li><p>A component should be <strong>self contained</strong>.</p>

                                <p class="note">This means that what is outside of the visual boundaries of the
                                    component doesn't belong in the component definition. Typically, things like margins or positioning
                                    should reside in the "specifics" folder, not in the component. This is required for your component to
                                    live in any possible context.</p>
                            </li>
                            <li><p><strong>Structure(layout) should be dissociated from skin(paint)</strong>.</p>

                                <p class="note">For example, background color, images, text colors, etc. should go into the skin section of the
                                    component,
                                    not in its core definition. That way, you can create additional styles for them without
                                    altering their expected behaviour as a component, and choose what visual style you want when binding
                                    the component to a classname.</p>
                            </li>
                        </ul>
                        <p>Of course, it's up to you to compose with those precepts and adapt them to your constraints, but
                            respecting them results in a clean separation of concerns and genuinely reusable components, which is much
                            likely to make your dev faster further down the road, and that
                            is what DoCSSa is aiming for.
                        </p>
                        <p class="note">
                            When beginning with DoCSSa, it's easy to think as everything as components, as they are so powerful.
                            You must be careful about that, and think about what needs to be a component and what doesn't.<br>
                            If you component-ize every set of rules, you risk spending more time building the same thing as you
                            would have in the "specifics" folder without enough additional value for it to be worth it.
                            Try to begin with small components to get the hang of it, and adjust your use little by little.<br>
                            You can begin everything the way you are used to in the "specifics" folder, organize it
                            in imported files and subfolders the DoCSSa way, and only extract a functionality to a component
                            when you feel that it would help you.<br>
                            DoCSSa only gives you tools to play with, what you implement and how you do things with it is up to you.
                            That's what we believe a "framework" should be anyway.
                        </p>
                        <h2 class="mainSection_subtitle">Description</h2>
                        <p>When looking at a component folder, you may see three files, and eventually some subfolders.
                            Let's take a <em>Tabs</em> component as an example, as probably everyone has already seen a tabbed
                            navigation in a page. The files in the Tabs folder would be: <em>_tabs.scss</em>, <em>tabs.standalone.scss</em>,
                            and <em>tabs.standalone.html</em>.
                        </p>
                        <p>The underscore prefixed file (_tabs.scss) is the component definition. It is the only essential file for the
                            component, the others are optional.<br>
                            Let's look at it in details.
                        </p>
                        <h3 class="mainSection_smallTitle" id="components_definition">Component's definition</h3>
                        <p>The component definition file contains two sets of placeholders
                            named after the component's name, and two mixins. One set is for the component structure, one for
                            the component's skin. Placeholders are wrapped in a <em>define</em> mixin, so that we can import the
                            component from anywhere without any risk of having our placeholders duplicated in the final css.
                        </p>
                        <p>Here's the <em>structure</em> part of our "tabs" component :</p>

                        <div class="sample">
                            <ul class="sampleHeader">
                                <li class="sampleHeader_item _is_current">
                                    <span class="sampleHeader_link">// components/tabs/_tabs.scss</span>
                                </li>
                            </ul>
<pre class="codeSample">
@import 'sass/base/utils/__utils';

// _____ STRUCTURE _____ //

// define component placeholders for component contents (no selector here except for component's id)
@include define('tabs') {

  %tabs {
    list-style: none;
    padding: 0;
    margin: 0;
    font-size: 0;
    display: inline-block;
  }

  %tabs_item{
    @include remIt(font-size, 18);
    padding: 10px 0;
    display: inline-block;
    vertical-align: bottom;
  }

  %tabs_link {
    padding: 0 10px;
  }

}


// map the placeholders content to some selectors through a mixin
@mixin tabs($selector, $defaultSkin: true) {

  #{$selector} {
    @extend %tabs;
  }

  #{$selector}_item {
    @extend %tabs_item;
  }

  #{$selector}_link {
    @extend %tabs_link;
  }



  @if $defaultSkin != false {
    @include tabs-skin-default($selector);
  }

}
</pre>


                        <p>Don't worry about the id selector for now, we'll get back to it in the "standalone component" chapter.</p>
                        <p>First, the component imports 'sass/base/utils/__utils', which will give it access to the default
                            mixins and helpers. Thanks to the <em>define</em> mixin, all components can safely import this folder.
                        </p>
                        <p>Then, a bunch of placeholders are defined, wrapped in a <em>define</em> mixin so that they can safely be imported
                            by subComponents if needed. They are the core of the component, and define what needs to be implemented
                            on the various classes or states of the component.<p>
                        <p>Below the defined wrapped placeholders is a mixin named after the component. Its role is to
                            actually bind the components placeholders to the provided classname, its "elements", and its state.
                        </p>
                        <p>By default, the component binding will also implement the default skin. If we have defined another
                            skin, all we need to do is pass "$defaultSkin: false" when instantiating the component, and
                            call another skin binding mixin to handle the component's skin.
                        </p>
                        <p class="note">We said earlier that a component folder may have subfolders. One of those is a "_skins"
                            folder that would host different skins that we could import as needed. The other possible folders
                            are subComponents folders, that would extend the component. The "_skins" folder is prefixed by an underscore only
                            so that it always show on top of the list, instead of appearing among the subComponents folders.
                        </p>
                        <p>Now let's look at the <em>skin</em> part of our "tabs" component :
                        </p>
                        <samp class="sampleTitle">// A component's skin part</samp>
<pre class="codeSample">
// _____ SKIN _____ //
@import 'sass/base/project/_variables';
@import 'sass/base/project/_helpers';


// define component placeholders for component skin (no selector here)
@include define('tabs-skin-default') {

  %tabs-skin-default__item {
    border-bottom: solid 3px transparent;
  }

  %tabs-skin-default__item_current {
    border-bottom: solid 3px $color-green;
  }

  %tabs-skin-default__item_hover {
    border-bottom: solid 3px $color-green-light;
  }


  %tabs-skin-default__link {
    border-left: solid 1px $color-green;
    text-decoration: none;
    color: $color-green;
  }

  %tabs-skin-default__link_first {
    border-left: inherit;
  }

  %tabs-skin-default__item_hover_link {
    color: $color-green-light;
  }

  %tabs-skin-default__item_current_link {
    color: $color-green-light;
  }

  %tabs-skin-default__item_highlighted {
    color: $color-grey-dark;
  }

}

// provide a default skin for the component
// only visual changes that don't affect the component layout should be in here
@mixin tabs-skin-default($selector) {

  #{$selector}_item {

    @extend %tabs-skin-default__item;

    &amp;._is_current {
      @extend %tabs-skin-default__item_current;
    }

    &amp;:hover {
      @extend %tabs-skin-default__item_hover;
    }


  }

  #{$selector}_link {

    @extend %tabs-skin-default__link;

    #{$selector}_item:first-child &amp; {
      @extend %tabs-skin-default__link_first;
    }

    &amp;:hover {
      @extend %tabs-skin-default__item_hover_link;
    }

    #{$selector}_item#{'--highlighted'} &amp; {
      @extend %tabs-skin-default__item_highlighted;
    }

    #{$selector}_item._is_current &amp; {
      @extend %tabs-skin-default__item_current_link;
    }
  }

}
</pre>

                        <p>As you can see, it is very close to the structure part. Actually it is placed inside the component's
                            folder for simplicity, but it could very well reside in a _skins folder right away.
                        </p>
                        <p>As the "skin" part of the component is usually project related, it makes sense that it imports
                            the _variables and _helpers files. This is only a requirement when generating standalone CSS, as those
                            files would be already imported from the custom.scss file in the context of your project.
                        </p>
                        <p class="note">We recommend that the "structure" part of the component doesn't make use of any
                            project variable in order to stay as generic and reusable as possible.<br>
                            Usually that is not a problem, but if for some reason you need to import the project variables anyhow for you
                            component structure,
                            you're just one @import away.
                        </p>
                        <p class="note">As stated before, a component's "structure" should only contain it's layout, it's skeleton.
                            The "skin" part, unlike the structure, should
                            <em>only
                                contain</em> rules that <em>don't affect</em> the structure. These rules can be
                            background-colors,
                            background-images, border-radius, shadows, opacity... Anything you want as long as it doesn't
                            fiddle with the component's external boundaries.<br>
                            It is not always easy, but the more you practice it
                            the
                            more it feels natural, and the easier it is to find out the right place when you come back to adjust
                            something about your component.
                        </p>
                        <h3 class="mainSection_smallTitle" id="components_implementation">Implementation</h3>
                        <p>Now that we know how a component is structured, it's time to implement it.
                            This is done by calling the component mixin and passing it a class selector.
                        </p>
                        <p>Here's what an implementation may look like :</p>
                        <samp class="sampleTitle">// in specifics/_main.scss</samp>
    <pre class="codeSample">
    @include tabs('.mainMenu');
    </pre>
                        <p>That's right, now that you have defined your component, using it is as easy as that!</p>
                        <p>And here is what the output css will look like :</p>




                        <samp class="sampleTitle">// in css/custom.css</samp>
<pre class="codeSample">
.mainMenu {
  list-style: none;
  padding: 0;
  margin: 0;
  font-size: 0;
  display: inline-block;
}

.mainMenu_item {
  font-size: 18px;
  padding: 10px 0;
  display: inline-block;
  vertical-align: bottom;
}
.cssremunit .mainMenu_item {
  font-size: 1.125rem;
}

.mainMenu_link {
  padding: 0 10px;
}


.mainMenu_item {
  border-bottom: solid 3px transparent;
}

.mainMenu_item._is_current {
  border-bottom: solid 3px #449888;
}

.mainMenu_item:hover {
  border-bottom: solid 3px #5cbcaa;
}

.mainMenu_link {
  border-left: solid 1px #449888;
  text-decoration: none;
  color: #449888;
}

.mainMenu_item:first-child .mainMenu_link {
  border-left: inherit;
}

.mainMenu_link:hover {
  color: #5cbcaa;
}

.mainMenu_item._is_current .mainMenu_link {
  color: #5cbcaa;
}

.mainMenu_item--highlighted .mainMenu_link {
  color: #333333;
}
</pre>
                        <p>If later on you need to bind the tabs component to another class, all you have to do is to call the mixin
                            with that class and the parameters you want, and you're done!
                        </p>
                        <p>For example :</p>
                        <samp class="sampleTitle">// in specifics/_main.scss</samp>
<pre class="codeSample">
@include tabs('.articleTabs', $defaultSkin: false);
@include tabs-skin-alternate('.articleTabs');
</pre>
                        <h2 class="mainSection_subtitle" id="components_standalone">Standalone component</h2>
                        <p>The _tabs.scss file is really the only one needed for your component, as long as it includes a skin
                            for the component. But there are two other files that we presented earlier : <em>tabs.standalone.scss</em>
                            and <em>tabs.standalone.html</em>.<br>
                            Those are here to provide a version of the component already bound to a classname, and
                            an html template describing what the associated markup should look like.<br>
                            As the tabs.standalone.scss file isn't prefixed with an underscore, it will get rendered by Sass into a .css file.
                            This can be useful when you want some javascript to dynamically instantiate a component and load
                            its associated CSS, instead of providing the component's CSS along with the main stylesheet.
                        </p>
                        <div class="exampleNote">
                            <p>Here's what the standalone scss file would look like for our tabs example :</p>
                            <samp class="sampleTitle">// tabs.standalone.scss</samp>
<pre class="codeSample">
@import '_tabs.scss';

#docssaComponent__tabs-dynamicTabs {
  content: 'loaded';
}

@include tabs('.dynamicTabs');
</pre>

                            <p>As you can see, we use an id in the standalone version of the component. It is intended
                                for load detection : <br>when dynamically loading components from javaScript, you should
                                first
                                check if it hasn't already been loaded from some other place, and only load it if
                                required.<br>
                                We recommend using the component name, separated by a dash from the classname it is
                                bound to,
                                and prefixed by <em>#docssaComponent</em>. <br>
                                This way you'll know what you're dealing with,
                                and avoid collision with other CSS selectors.</p>
                        </div>


                        <p>Each component folder should also contain a standalone version and a HTML example, so
                            that fellow developers
                            know what is the expected structure HTML-wise and can test the result easily.<br>
                            Components need a structure to apply on. If they didn't, a placeholder helper would be
                            enough.<br>
                            It can be really useful to maintain a project Style Guide, including every component
                            standalone as a reference.
                        </p>

                        <div class="exampleNote">
                            <p>Here's what the html sample file may look like for our tabs example :</p>

                            <samp class="sampleTitle">// tabs.standalone.html</samp>
<pre class="codeSample">
&lt;ul class="dynamicTabs"&gt;
    &lt;li class="dynamicTabs_item"&gt;
        &lt;a class="dynamicTabs_link" href="#tabContent1"&gt;tabContent1&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class="dynamicTabs_item"&gt;
        &lt;a class="dynamicTabs_link" href="#tabContent2"&gt;tabContent2&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class="dynamicTabs_item"&gt;
        &lt;a class="dynamicTabs_link" href="#tabContent3"&gt;tabContent3&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class="dynamicTabs_item"&gt;
        &lt;a class="dynamicTabs_link" href="#tabContent4"&gt;tabContent4&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class="dynamicTabs_item"&gt;
        &lt;a class="dynamicTabs_link" href="#tabContent5"&gt;tabContent5&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class="dynamicTabs_item"&gt;
        &lt;a class="dynamicTabs_link" href="#tabContent6"&gt;tabContent6&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</pre>

                        </div>
                    </div>
                </section>

                <hr class="articleSeparator">

                <section class="mainSection" id="namingConventions">

                    <header class="mainSection_header">
                        <h1 class="mainSection_title">Naming conventions</h1>
                    </header>

                    <div class="mainSection_body">
                        <h2 class="mainSection_subtitle">HTML classes</h2>

                        <p>In DoCSSa, we decided to follow BEM class naming convention.<br>
                            HTML class names for <em>Blocks</em> are lowerCamelCase, and the <em>Elements</em> nested
                            within are separated by
                            an underscore(_). <em>Modifiers</em> are separated by a double dash(--), and they are used
                            for elements
                            <em>variants</em>. An element's <em>state</em> is written separately with a pattern that
                            begins with "_is_".
                        </p>

                        <p class="note">
                            <em>Variants</em> are dissociated from <em>states</em> because they play a different role,
                            and it appeared
                            that with our components architecture, having a simple "_is_current" class for our items'
                            "current" state was
                            way more
                            effective than a "mainMenu_item--current" when it came to modifying the state through
                            javascript.<br>
                            BEM modifiers are now exclusively used for visual variants that don't change over time. For
                            example,
                            if a tab needs to be highlighted so that it stand out, it is applied a variant.<br>
                            By opposition, a "state" is something that is supposed to be handled by javascript and
                            change over time.
                        </p>

                        <div class="exampleNote">
                            <p>Here is an example of what that convention may look like in our tab example :</p>
                            <samp class="sampleTitle">// naming example</samp>
<pre class="codeSample">
&lt;nav class="mainNav"&gt;
    &lt;ul class="mainMenu"&gt;
        &lt;li class="mainMenu_item"&gt;
            &lt;a class="mainMenu_link" href="#"&gt;Home&lt;/a&gt;
        &lt;/li&gt;
        &lt;li class="mainMenu_item"&gt;
            &lt;a class="mainMenu_link" href="#about"&gt;About&lt;/a&gt;
        &lt;/li&gt;
        &lt;li class="mainMenu_item"&gt;
            &lt;a class="mainMenu_link" href="#fileStructure"&gt;File Structure&lt;/a&gt;
        &lt;/li&gt;
        &lt;li class="mainMenu_item"&gt;
            &lt;a class="mainMenu_link" href="#components"&gt;Components&lt;/a&gt;
        &lt;/li&gt;
        &lt;li class="mainMenu_item _is_current"&gt;
            &lt;a class="mainMenu_link" href="#namingConventions"&gt;Naming conventions&lt;/a&gt;
        &lt;/li&gt;
        &lt;li class="mainMenu_item"&gt;
            &lt;a class="mainMenu_link" href="#responsive"&gt;Responsive&lt;/a&gt;
        &lt;/li&gt;
        &lt;li class="mainMenu_item"&gt;
            &lt;a class="mainMenu_link" href="#gettingStarted"&gt;Getting started&lt;/a&gt;
        &lt;/li&gt;
        &lt;li class="mainMenu_item mainMenu_item--highlighted"&gt;
            &lt;a class="mainMenu_link" href="#contributing"&gt;Contributing&lt;/a&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav>
</pre>
                            Note that this example is taken from the menu you're looking at just now in the present
                            page.
                        </div>
                        <p>At first, the BEM notation style can seem quite verbose and put off some developers, but it
                            is very
                            powerful and allows us to go way behind old school naming conventions.<br>
                            It has to be tamed, though, and a classic beginner's mistake is to reflect the position of
                            each
                            element in the component's DOM in its class name. To avoid that, we recommend that you look
                            at your
                            low level elements first (those deeper in the DOM tree) and wonder if they could exist
                            elsewhere in the page
                            or in the component.
                            Going up the tree, you can identify your most basic reusable components and set the names
                            accordingly.
                        </p>

                        <p class="exampleNote">
                            For example, in our example above, the "mainMenu_link" class doesn't need to reflect the
                            fact that it
                            is contained in a "mainMenu_item", this doesn't really matter to the link, so there is no
                            reason to
                            specify it in its name.
                        </p>

                        <h2 class="mainSection_subtitle">Sass files</h2>

                        <p>We talked about some of the aspects of the Sass file naming convention in the "File
                            Structure" section.</p>

                        <p>Each file is lowerCamelCase named and prefixed by an underscore(_) so that it is considered
                            by the Sass compiler
                            as a partial and
                            not rendered to a standalone CSS file. The only exception to this rule is the components'
                            standalone
                            versions (see the "Components" section for details about this).
                        </p>

                        <p>
                            Each folder has a single entry point in charge of importing other partial Sass files. This
                            file is
                            named after the folder's name, and is prefixed with two underscores(__) so that it always
                            appears on top
                            in the files list. It imports only the files in its own folder, except for other summary
                            index located in
                            a direct subfolder. This way, you always can handle your imports very easily and stop the
                            imports
                            of nested files at any level.<br>
                            Components definition files should have the same name as the component's folder name, and
                            have a
                            single underscore prefix.
                        </p>

                        <h2>Sass contents</h2>

                        <p>For placeholders, used in the _helpers files or the components definitions, we recommend a
                            mix of lowerCamelCase,
                            dashes(-) and underscores(_). Helpers and components prefix should stick to lowerCamelCase,
                            while components
                            placeholders should include the component's prefix and separate sub parts from it with a
                            dash or underscore.
                            Sass treats dashes and underscores as if they were the same character, so they are totally
                            invertible.
                        </p>

                        <p class="note">
                            Note that those are only guidelines, and if for any reason you prefer to go with another
                            convention
                            in your project, you're free to do so. HTML classes and file names conventions have a
                            rationale behind
                            them which offers you some advantages, but for the sass files contents it's really just a
                            matter of
                            preference. We offer a suggestion only to provide some common ground for DoCSSa users.
                        </p>

                        <div class="exampleNote">
                            <p>For example, you could pass ".myExampleClass" as a selector to a component mixin for an
                                implementation that
                                would look like this :
                            </p>
                            <samp class="sampleTitle">// example</samp>
<pre class="codeSample">
#{$selector} {
  @extend %componentName;
}
#{$selector}__singleItem {
  @extend %componentName__singleItem
  &amp;:hover {
    @extend %componentName__singleItem-altState
  }
}
</pre>
                        </div>
                        <h2>SASS variables</h2>

                        <p>Sass variable names should be composed of dash(-) separated parts, with each part sorted from
                            the most
                            generic to the most specific variable characteristic. This is quite useful in most IDE as
                            you can take
                            advantage of autocompletion.
                        </p>

                        <div class="exampleNote">
                            <p>For example :</p>
                            <samp class="sampleTitle">// variables example</samp>
<pre class="codeSample">
/* _____ VARIABLES _____ */

// Generic
// ==========================================================================

$default-borderRadius: 4px;

$containerWidth: 760px;

$variant: 'base';


// Colors
// ==========================================================================

$color-default-black: #000;
$color-default-white: #fff;

$color-green: #449888;
$color-green-light: #5cbcaa;
$color-green-lighter: #a8d5cd;
$color-pink: #ee746f;
$color-grey-dark: #333;
$color-beige-dark: #c2c0bc;
$color-beige: #f1ede4;
$color-beige-light: #f8f5ec;

$color-code: #637c84;
</pre>
                        </div>
                    </div>
                </section>


                <hr class="articleSeparator">

                <section class="mainSection" id="responsive">

                    <header class="mainSection_header">
                        <h1 class="mainSection_title">Responsive</h1>
                    </header>

                    <div class="mainSection_body">
                        <p>As you may have noticed, DoCSSa makes a quite heavy use of Sass placeholders. This is nice until
                        you try to use them from within a media query, and stumble onto the dreaded <em>"You may not @extend
                        an outer selector from within @media. You may only @extend selectors within the same directive."</em>
                        error message. <br>
                            But fear not, my friend! Until this gets fixed in Sass, there are ways around it.</p>
                        <p>In order to be able to use your components in any context, you'll only have a few things to keep in mind:</p>
                        <ul>
                            <li>All <strong>breakpoints need to be named and predefined</strong> in the <strong>$breakpoints variable</strong> located in
                                base/_config.scss
                            </li>
                            <li><strong>Placeholders definition</strong> need to be done through the provided <strong>_add()</strong> mixin</li>
                            <li><strong>Placholders use</strong> need to be done through the provided <strong>_use()</strong> mixin</li>
                            <li><strong>@media blocks</strong> need to be called through the provided <strong>breakpoint()</strong> mixin</li>
                        </ul>
                        <p>If you respect this process, which is a bargain, you can enjoy helpers and components anywhere
                            in your sass structure. Aren't you just glad you came ?</p>

                        <div class="exampleNote">
                            <p>Here is how we implemented our "clearfix" helper for a responsive environment :</p>

                            <samp class="sampleTitle">// in utils/_helpers.scss</samp>
<pre class="codeSample">
@include _add(clearfix) {
  &amp;:before,
  &amp;:after {
    content: " ";
    display: table;
  }
  &amp;:after {
    clear: both;
  }
  *zoom: 1;
}
</pre>
                            <p>As you can see, we just replaced the traditional <em>%clearfix</em> definition with
                                <em>@include _add(clearfix)</em>.</p>
                            <p class="note">If you've already defined placeholders in DoCSSa before,
                                a simple regex can do the conversion for you : replace <em>%([^ {]+)\s*\{</em>
                                with <em>@include _add($1) {</em> and you're done!
                                </p>
                            <p>When creating the <em>_add()</em> mixin, we made sure it wouldn't break compatibility.
                            That means that our clearfix placeholder can still be used with a simple <em>@extend %clearfix</em>
                                as long as you're not within a media query block. But now, it can do much more!</p>
                            <p>First, you need to define the breakpoints :</p>
                            <samp class="sampleTitle">// in base/_config.scss</samp>
<pre class="codeSample">
$breakpoints: (
  "small": 600px,
  "medium": 900px,
  "large": 1200px
);
</pre>
                            <p>Once this is done, you can call the "clearfix" placeholder from within a media query with the
                            following syntax:</p>
                            <samp class="sampleTitle">// crossmedia placeholders example</samp>
<pre class="codeSample">
.a {
  @include _use(clearfix);
}

.b {
  @extend %clearfix;
}

.c {
  @include breakpoint(medium) {
    @include _use(clearfix);
  }
}

@include breakpoint(medium) {
  .d {
    @include _use(clearfix);
  }
}

.e {
  @include _use(clearfix);

  @include breakpoint(large) {
    @include _use(clearfix);
  }
}
</pre>
                            <p>Here is what the end result would look like in your custom.css file :</p>
<pre class="codeSample">
@media (min-width: 900px) {
  .c,
  .d {
    *zoom: 1;
  }
  .c:before,
  .d:before,
  .c:after,
  .d:after {
    content: " ";
    display: table;
  }
  .c:after,
  .d:after {
    clear: both;
  }
}
@media (min-width: 1200px) {
  .e {
    *zoom: 1;
  }
  .e:before,
  .e:after {
    content: " ";
    display: table;
  }
  .e:after {
    clear: both;
  }
}
.a,
.b,
.e {
  *zoom: 1;
}
.a:before,
.b:before,
.e:before,
.a:after,
.b:after,
.e:after {
  content: " ";
  display: table;
}
.a:after,
.b:after,
.e:after {
  clear: both;
}
</pre>
                        </div>
                        <p>As you can see, everything ends up nicely in the correct media query, as if you had wrote it
                        down manually. There is a little difference with the old school, hands in the dirt approach though:
                        you can now have your logic in a single place, and stay DRY all the way!</p>
                    </div>
                </section>

                <hr class="articleSeparator">

                <section class="mainSection" id="gettingStarted">

                    <header class="mainSection_header">
                        <h1 class="mainSection_title">Getting started</h1>
                    </header>

                    <div class="mainSection_body">

                        <h2 class="mainSection_subtitle">Download the kit</h2>
                        Download this page and its implementation of DoCSSa and play with it.<br>
                        Source code can be found on <a class="externalLink" href="https://github.com/mlarcher/docssa">
                        DoCSSa's github page</a>.
                        <h2 class="mainSection_subtitle">Learn about the basics</h2>
                        <ul class="firstOrderList">
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="externalLink" href="http://alistapart.com/article/getting-started-with-sass">
                                        Getting started with SASS [article]
                                    </a>
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="externalLink" href="http://www.sitepoint.com/cross-media-query-extend-sass/">
                                        Cross media query extend
                                    </a>
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="externalLink" href="http://www.creativebloq.com/css3/create-modular-and-scalable-css-9134351)">
                                        Four ways to create CSS that's modular and scalable [article]
                                    </a>
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="externalLink" href="http://bem.info/">
                                        BEM methodology [official website]
                                    </a>
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    <a class="externalLink" href="http://www.youtube.com/watch?v=vAs9tjEkkKk">
                                        Shubhie Panicker - CSS module system in Google+ (CSSconf.eu 2013) [video]
                                    </a>
                                </div>
                            </li>
                        </ul>
                        <h2 class="mainSection_subtitle">How to start ?</h2>
                        <ol class="firstOrderList">
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    First, you can simply write CSS code in separated files into the "specifics" folder,
                                    using DoCSSa's logic.
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    Then, try manipulating the provided "_helpers" and "_mixins" from the base/utils folder
                                    to give your project more reusable code.
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    After that, you may write your own "_helpers" and "_mixins", tailored for your own
                                    specific needs.
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    For more reusability within or across your project(s), you may then try to convert some of your "specifics" rules into "components".<br>
                                    If see you are repeating the same rules on different sets of classes, you have a good candidate.
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    Cherry on the cake, you can finally add responsive super powers to your components.
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    Been there, done that ? It's time to preach the choir ;)
                                </div>
                            </li>
                        </ol>

                        <h2>I'm the team lead of a non expert koala army, how can I make use of DoCSSa's powers ?</h2>
                        <ol class="firstOrderList">
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    While your koalas are learning Sass, they can keep writing the same old CSS in 'specifics' folder
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    Once one of them feels ready to, let her write "_helpers", and let the whole team know
                                    they can use them.
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    It won't be long before some other koalas would like to write _helpers or _mixins.
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    With knowledge adding up, it will become easier to detect components candidates.
                                </div>
                            </li>
                            <li class="firstOrderList_item">
                                <div class="firstOrderList_item_content">
                                    Don't forget to offer your koalas a lot of eucalyptus regularly.
                                </div>
                            </li>
                        </ol>

                    </div>
                </section>

                <hr class="articleSeparator">

                <section class="mainSection" id="contributing">

                    <header class="mainSection_header">
                        <h1 class="mainSection_title">Contributing</h1>
                    </header>

                    <div class="mainSection_body">

                        <h2 class="mainSection_subtitle">Contact us</h2>

                        <p>DoCSSa is evolving!<br>
                            We are very interested in your feedback to improve it or learn about how you implemented
                            it.<br>
                            Please <a class="navLink" href="https://github.com/mlarcher/docssa/#creators">contact us</a>, fork
                            <a class="externalLink" href="https://github.com/mlarcher/docssa">the project</a>, make Pull Requests
                            or talk about DoCSSa at will.
                        </p>
                    </div>
                </section>

            </article>

            <footer class="mainFooter">
                Presented by <a class="mainFooterLink" href="https://twitter.com/larchermatthieu">Matthieu Larcher</a> &amp;
                <a class="mainFooterLink" href="https://twitter.com/_faz">Fabien Zibi</a>

                <ul class="repoWrapper">
                    <li class="repoWrapper_item">
                        <iframe class="repoWrapper_iframe" src="http://ghbtns.com/github-btn.html?user=mlarcher&repo=docssa&type=fork&count=true" height="20" width="90" frameborder="0" scrolling="0" style="width:90px; height: 20px;" allowTransparency="true"></iframe>
                    </li>
                    <li class="repoWrapper_item">
                        <iframe class="repoWrapper_iframe" src="http://ghbtns.com/github-btn.html?user=mlarcher&repo=docssa&type=watch&count=true" height="20" width="80" frameborder="0" scrolling="0" style="width:90px; height: 20px;" allowTransparency="true">
                        </iframe>
                    </li>
                    <li class="repoWrapper_item">
                        <a class="repoWrapper_link" href="https://github.com/mlarcher/docssa">github</a>
                    </li>
                </ul>
            </footer>

        </div>

        <button class="goTop"></button>

        <script src="js/jquery.min.js"></script>
        <script src="js/main.js" async></script>

        <script>
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
                a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-50620385-1', 'docssa.info');
            ga('send', 'pageview');

        </script>

    </body>
</html>
